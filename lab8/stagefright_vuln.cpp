// Stagefright example:
//
// This illustrates the implicit coercion issues that occur in the
// Stagefright vulnerability in Android. The implicit coercion issue occurs
// because some of the integers are 32 bit unsigned and some are 64 bit
// unsigned. Math operations between mixed types undergo implicit coercion.
//
// The original vulnerability involved a coercion of (size + chunk_size).
// The size variable is a 32 bit unsigned integer while the chunk_size 
// variable is 64 bit unsigned integer. The new command took a 32 bit 
// unsigned integer. The expression (size + chunk_size) can result in a 
// value too large for a 32 bit unsigned integer. This could cause overflow,
// resulting in an abnormally small size request to the new command (as low
// as 0 bytes). Meanwhile, chunk_size was used to access the buffer, raising
// the possibility of accessing memory that was not allocated to the buffer.
//
// Melissa Danforth 25 Oct 2015 (updated 16 Oct 2022)

#include <iostream>
using namespace std;

const uint32_t MAX_SIZE = 0xFFFFFFFF;

void print_stage(uint32_t size, uint64_t chunk_size);

int main()
{
  uint32_t size = 1;
  uint64_t chunk_size = 0x1FFFFFFFF;

  cout << "Example 1: (truncation on assignment)" << endl;
  print_stage(size, chunk_size);

  cout << "Example 2: (addition overflow)" << endl;
  size = MAX_SIZE;
  chunk_size = 0xFFFFFFFFFFFFFFFF;
  print_stage(size, chunk_size);

  cout << "Example 3: (truncation on assignment)" << endl;
  size = MAX_SIZE;
  chunk_size = MAX_SIZE;
  print_stage(size, chunk_size);

  return 0;
}

void print_stage(uint32_t size, uint64_t chunk_size)
{
  cout << "size                  = 0x" << (std::hex) << size << endl;
  cout << "MAX_SIZE              = 0x" << (std::hex) << MAX_SIZE << endl;
  cout << "chunk_size            = 0x" << (std::hex) << chunk_size << endl;

  // Check on chunk size
  cout << endl;
  if(chunk_size > MAX_SIZE) {
    cout << "chunk_size is larger than a 32-bit integer.\n";
  }
  else {
    cout << "chunk_size is within the 32-bit integer range.\n";
  }

  // Do the "simple" allocation that is vulnerable to the type conversion
  // error, resulting in integer overflow for specially selected values.
  uint32_t alloc = size + chunk_size;
  cout << endl;
  cout << "Addition result       = 0x" << (std::hex) << 
      (size + chunk_size) << endl;
  cout << "Allocation request    = 0x"  << (std::hex) << alloc << endl;
  cout << endl << endl;
}

